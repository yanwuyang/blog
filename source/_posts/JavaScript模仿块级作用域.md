---
title: JavaScript模仿块级作用域
date: 2013-07-17
comments: true
categories: JavaScript
toc: false 
---

JavaScript没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。
```javascript
function ouputNumbers(count){
     for(var i=0;i<count;i++){
                ...
     }
     alert(i);//i==count
}
```
<!--more-->
这个函数中定义了一个for函数，而变量i的初始值被设置为了0。在Java、C++等语言中，变量i只会在for循环的语句块中有定义，循环一旦结束，变量i就会别销毁。可是在JavaScript中，变量是定义在outputNumbers()的活动对象中的，因此从它定义开始，就可以在函数内部随处访问它，即使下面这样错误地声明同一个变量，也不会改变他的值。

```javascript
function outputNumbers(count){
    for(var i=0;i<count;i++){
        alert(i);
    }
    var i;//重新声明变量
    alert(i);//i==count
}
```
JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。
用作块级作用域（通常称为私有作用域）的匿名函数语法如下所示
```javascript
(function(){
    //这里是块级作用域
})();
```
以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对括号中，表示它实际上是一个函数表达式。而紧随其后的另一对括号会立即调用这个函数。如果有读者感觉这种语法不太好理解，可以在看看下面这个例子。
```javascript
var count =5;
outputNumbers(count);
```
这里初始化了变量count，将其值设为5，当然，这里的变量是没有这个必要的，因为可以把值直接传给函数。为了让代码更加简洁，我们在调用函数的时用5来代替变量count，如下所示。
```javascript
outputNumbers(5);
```
这样做之所以可行，是因为变量只不过是值得另一种表达式，因此用实际的值替换变量没有问题，在看下面的例子。
```javascript
var someFunction = function(){
    //这里是块级作用域
};
someFunction();
```
这个例子先定义了一个函数，然后立即调用了它，定义函数的方式是创建一个匿名函数，并吧匿名的函数赋值给变量someFunction。而调用函数的方式是在函数名称后面添加一对括号，即someFunction()。通过前面的例子我们知道，可以使用实际的值来取代变量count，那在这里是不是也可以用函数的值直接取代函数名呢？下面的代码却会导致错误。
```javascript
function(){
    //这里是块级作用域
}();//出错
```
这段代码会导致语言错误，是因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟园括号。然后，函数表达式的后面可以跟圆括号。要将函数声明转发转换成函数表达式。只要像下面这样的给他加上一对括号即可。
```javascript
(function(){
    //这里是块级作用域
})();
```
无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：
```javascript
function outputNumbers(count){
    (function(){
        for(var i=0;i<count;i++){
            alert(i);
        }
    })();
    alert(i);//导致一个错误！
}
```
在这个重写的outputNumbers()函数中。我们在for循环外部插入了一个私有作用域。在匿名函数中定义的任何变量，都会在执行结束时被销毁。因此，变量i只能在循环中使用，使用后即销毁。而在私有作用域中能够访问变量count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。
这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突，而通过创建私有作用域，每个开发人员即可以实用自己的变量，又不必担心搞乱全局作用域。例如：
```javascript
(function(){
    var now = new Date();
    if(now.getMont()==0 && now.getDate() ==1){
        alert("Happy new year");
    }
})();
```
把上面这段代码放在全局作用域中，可以用来确定那一天是1月1日；如果到了这一天，就会向用户显示一条祝贺新年的消息。其中的变量now现在是在匿名函数中的局部变量，而我们不必再全局作用域中创建他。

***注意：***
这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数指向完毕，就可以理解销毁其作用域链了。