---
title: JavaScript闭包
date: 2013-07-17
comments: true
categories: JavaScript
toc: false 
---

有很多开发人员总数搞不清匿名函数和闭包这两个概念，因此经常混合使用。闭包是指有权访问另一个匿名函数作用域中的变量函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。
```javascript
function createComparisonFunction(name){
  return function(object1){
       return object1[name];
  }
}
```
<!--more-->
变量name即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可以访问变量name，之所以还能够访问这个变量，是因为内部函数的作用域链中包含了createComparisonFunction的作用域。要彻底搞清楚其中的细节，必须要从理解函数第一次被调用的时候都发生什么入手。
有关如何创建作用域链以及作用域链有什么作用细节，对彻底理解闭包至关重要。当某个函数被调用时，会创建一个执行环境以及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，......直至作为作用域链终点的全局执行环境。
在函数执行过程中，为读取和写入变量的值，就需要在作用域中查找变量。来看下下面的例子。

```javascript
function compare(value1,value2){
  if(value1<value2){
     return -1;
  }else if(value1>value2){
     return 1;
  }else{
     return 0;
  }  
}
var result = compare(5,10);
```
以上代码先定义了compare()函数，然后又在全局作用域中调用了它，当第一次调用compare()时，会创建一个包含this、arguments、value1、value2的活动对象。全局执行环境的变量对象（包含this、result、和compare）在compare()执行环境的作用域链中则处于第二位。

后台的每一个执行环境都有一个表示变量的对象——变量对象。全局的变量对象始终存在，而像compare()函数这样的局部环境中的变量对象，则只是在函数执行过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中的compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，他只是引用但不时间包含变量对象。

无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。

在另一个函数内部定义的函数会将包含函数（及外部函数）的活动对象添加到他的作用域链中。因此，在createCompareFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createCompareFunction()的活动对象。

由于闭包会携带包含的函数作用域，因此会比其他函数占用更多的内存资源。过度使用闭包可能会导致内存占用过多，我们建议只有在绝对必要时在考虑使用闭包。